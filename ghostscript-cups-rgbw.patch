diff -up ghostscript-9.04/cups/gdevcups.c.cups-rgbw ghostscript-9.04/cups/gdevcups.c
--- ghostscript-9.04/cups/gdevcups.c.cups-rgbw	2011-08-16 14:47:10.311813968 +0100
+++ ghostscript-9.04/cups/gdevcups.c	2011-08-16 14:48:02.291224871 +0100
@@ -225,6 +225,7 @@ typedef struct gx_device_cups_s
   unsigned short	EncodeLUT[gx_max_color_value + 1];/* RGB value to output color LUT */
   int			Density[CUPS_MAX_VALUE + 1];/* Density LUT */
   int			Matrix[3][3][CUPS_MAX_VALUE + 1];/* Color transform matrix LUT */
+  int                   user_icc;
   int                   cupsRasterVersion;
 
   /* Used by cups_put_params(): */
@@ -426,6 +427,7 @@ gx_device_cups	gs_cups_device =
   {0x00},                                  /* EncodeLUT */
   {0x00},                                  /* Density */
   {0x00},                                  /* Matrix */
+  0,
   3                                     /* cupsRasterVersion */
 };
 
@@ -1183,15 +1185,18 @@ cups_map_cmyk(gx_device *pdev,		/* I - D
 
     case CUPS_CSPACE_RGB :
     case CUPS_CSPACE_RGBW :
+        c0 = c + k;
+        c1 = m + k;
+        c2 = y + k;
         if (cups->header.cupsColorSpace == CUPS_CSPACE_RGBW) {
-	  c0 = c;
-	  c1 = m;
-	  c2 = y;
-	  c3 = k;
-	} else {
-	  c0 = c + k;
-	  c1 = m + k;
-	  c2 = y + k;
+	  if ((k >= frac_1 - 1) ||
+	      ((c0 >= frac_1) && (c1 >= frac_1) && (c2 >= frac_1))) {
+	    c0 = frac_1;
+	    c1 = frac_1;
+	    c2 = frac_1;
+	    c3 = frac_1;
+	  } else
+	    c3 = 0;
 	}
 
         if (c0 < 0)
@@ -1213,11 +1218,12 @@ cups_map_cmyk(gx_device *pdev,		/* I - D
 	out[2] = frac_1 - (frac)cups->Density[c2];
 
         if (cups->header.cupsColorSpace == CUPS_CSPACE_RGBW) {
-	  if (c3 < 0)
-	    c3 = 0;
-	  else if (c3 > frac_1)
-	    c3 = frac_1;
-	  out[3] = frac_1 - (frac)cups->Density[c3];
+	  if (c3 == 0)
+	    out[3] = frac_1;
+	  else if (c3 == frac_1)
+	    out[3] = 0;
+	  else
+	    out[3] = frac_1;
 	}
         break;
 
@@ -2035,10 +2041,15 @@ cups_map_color_rgb(gx_device      *pdev,
         * cups->DecodeLUT actually maps to RGBW, not CMYK...
 	*/
 
-        k = cups->DecodeLUT[c3];
-        c = cups->DecodeLUT[c0] + k - gx_max_color_value;
-        m = cups->DecodeLUT[c1] + k - gx_max_color_value;
-        y = cups->DecodeLUT[c2] + k - gx_max_color_value;
+        if (c3 == 0) {
+	  c = 0;
+	  m = 0;
+	  y = 0;
+	} else {
+	  c = cups->DecodeLUT[c0];
+	  m = cups->DecodeLUT[c1];
+	  y = cups->DecodeLUT[c2];
+	}
 
         if (c > gx_max_color_value)
 	  prgb[0] = gx_max_color_value;
@@ -2283,20 +2294,20 @@ cups_map_rgb_color(gx_device      *pdev,
           switch (cups->header.cupsBitsPerColor)
           {
             default :
-        	i = 0x0e;
+        	i = 0x00;
         	break;
             case 2 :
-        	i = 0xfc;
+        	i = 0x00;
         	break;
             case 4 :
-        	i = 0xfff0;
+        	i = 0x0000;
         	break;
             case 8 :
-        	i = 0xffffff00;
+        	i = 0x00000000;
         	break;
 #ifdef GX_COLOR_INDEX_TYPE
 	    case 16 :
-		i = 0xffffffffffff0000;
+		i = 0x0000000000000000;
 		break;
 #endif /* GX_COLOR_INDEX_TYPE */
           }
@@ -2930,6 +2941,7 @@ cups_put_params(gx_device     *pdev,	/* 
   int                   xflip = 0,
                         yflip = 0;
   int                   found = 0;
+  gs_param_string icc_pro_dummy;
 
 #ifdef DEBUG
   dprintf2("DEBUG2: cups_put_params(%p, %p)\n", pdev, plist);
@@ -3025,6 +3037,11 @@ cups_put_params(gx_device     *pdev,	/* 
   margins_set = param_read_float_array(plist, "Margins", &arrayval) == 0;
   color_set   = param_read_int(plist, "cupsColorSpace", &intval) == 0 ||
                 param_read_int(plist, "cupsBitsPerColor", &intval) == 0;
+
+  if (!cups->user_icc) {
+      cups->user_icc = param_read_string(plist, "OutputICCProfile", &icc_pro_dummy) == 0;
+  }
+
   /* We set the old dimensions to 1 if we have a color depth change, so
      that memory reallocation gets forced. This is perhaps not the correct
      approach to prevent crashes like in bug 690435. We keep it for the
@@ -4045,22 +4062,80 @@ cups_set_color_info(gx_device *pdev)	/* 
     for (k = 0; k <= CUPS_MAX_VALUE; k ++)
       cups->Density[k] = k;
   }
-  /* Set up the ICC profile for ghostscript to use based upon the color space.
-     This is different than the PPD profile above which appears to be some sort
-     of matrix based TRC profile */
-  switch (cups->header.cupsColorSpace) {
-      /* Use RGB profile for this */
-    case CUPS_CSPACE_RGBW:
-      if (pdev->icc_struct == NULL) {
-        pdev->icc_struct = gsicc_new_device_profile_array(pdev->memory);
-      }
-      if (pdev->icc_struct->device_profile[gsDEFAULTPROFILE] == NULL) {
-            code = gsicc_set_device_profile(pdev, pdev->memory, 
-                DEFAULT_RGB_ICC, gsDEFAULTPROFILE);
-      }
-      break;
-    default:
-      break;
+  if (!cups->user_icc) {
+    /* Set up the ICC profile for ghostscript to use based upon the color space.
+       This is different than the PPD profile above which appears to be some sort
+       of matrix based TRC profile */
+    switch (cups->header.cupsColorSpace)
+    {
+      default :
+      case CUPS_CSPACE_RGBW :
+      case CUPS_CSPACE_W :
+      case CUPS_CSPACE_WHITE :
+      case CUPS_CSPACE_RGB :
+      case CUPS_CSPACE_RGBA :
+#    ifdef CUPS_RASTER_HAVE_COLORIMETRIC
+      case CUPS_CSPACE_CIEXYZ :
+      case CUPS_CSPACE_CIELab :
+      case CUPS_CSPACE_ICC1 :
+      case CUPS_CSPACE_ICC2 :
+      case CUPS_CSPACE_ICC3 :
+      case CUPS_CSPACE_ICC4 :
+      case CUPS_CSPACE_ICC5 :
+      case CUPS_CSPACE_ICC6 :
+      case CUPS_CSPACE_ICC7 :
+      case CUPS_CSPACE_ICC8 :
+      case CUPS_CSPACE_ICC9 :
+      case CUPS_CSPACE_ICCA :
+      case CUPS_CSPACE_ICCB :
+      case CUPS_CSPACE_ICCC :
+      case CUPS_CSPACE_ICCD :
+      case CUPS_CSPACE_ICCE :
+      case CUPS_CSPACE_ICCF :
+#    endif /* CUPS_RASTER_HAVE_COLORIMETRIC */
+        if (pdev->icc_struct == NULL) {
+          pdev->icc_struct = gsicc_new_device_profile_array(pdev->memory);
+        }
+        if (pdev->icc_struct->device_profile[gsDEFAULTPROFILE]) {
+          rc_decrement(pdev->icc_struct->device_profile[gsDEFAULTPROFILE], "cups_set_color_info");
+          pdev->icc_struct->device_profile[gsDEFAULTPROFILE] = NULL;
+        }
+        code = gsicc_set_device_profile(pdev, pdev->memory, 
+            (char *)DEFAULT_RGB_ICC, gsDEFAULTPROFILE);
+        break;
+
+      case CUPS_CSPACE_K :
+        if (pdev->icc_struct == NULL) {
+          pdev->icc_struct = gsicc_new_device_profile_array(pdev->memory);
+        }
+        if (pdev->icc_struct->device_profile[gsDEFAULTPROFILE]) {
+          rc_decrement(pdev->icc_struct->device_profile[gsDEFAULTPROFILE], "cups_set_color_info");
+          pdev->icc_struct->device_profile[gsDEFAULTPROFILE] = NULL;
+        }
+        code = gsicc_set_device_profile(pdev, pdev->memory, 
+            (char *)DEFAULT_GRAY_ICC, gsDEFAULTPROFILE);
+          break;
+      case CUPS_CSPACE_GOLD :
+      case CUPS_CSPACE_SILVER :
+      case CUPS_CSPACE_CMY :
+      case CUPS_CSPACE_YMC :
+      case CUPS_CSPACE_KCMYcm :
+      case CUPS_CSPACE_CMYK :
+      case CUPS_CSPACE_YMCK :
+      case CUPS_CSPACE_KCMY :
+      case CUPS_CSPACE_GMCK :
+      case CUPS_CSPACE_GMCS :
+        if (pdev->icc_struct == NULL) {
+          pdev->icc_struct = gsicc_new_device_profile_array(pdev->memory);
+        }
+        if (pdev->icc_struct->device_profile[gsDEFAULTPROFILE]) {
+          rc_decrement(pdev->icc_struct->device_profile[gsDEFAULTPROFILE], "cups_set_color_info");
+          pdev->icc_struct->device_profile[gsDEFAULTPROFILE] = NULL;
+        }
+        code = gsicc_set_device_profile(pdev, pdev->memory, 
+            (char *)DEFAULT_CMYK_ICC, gsDEFAULTPROFILE);
+          break;
+    }
   }
 }
 
